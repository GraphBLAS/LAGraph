\begin{verbatim}
int LAGraph_Malloc
(
    // output:
    void **p,               // pointer to allocated block of memory
    // input:
    size_t nitems,          // number of items
    size_t size_of_item,    // size of each item
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Calloc
(
    // output:
    void **p,               // pointer to allocated block of memory
    // input:
    size_t nitems,          // number of items
    size_t size_of_item,    // size of each item
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Realloc
(
    // input/output:
    void **p,               // old block to reallocate
    // input:
    size_t nitems_new,      // new number of items in the object
    size_t nitems_old,      // old number of items in the object
    size_t size_of_item,    // size of each item
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Free            // free a block of memory and set p to NULL
(
    // input/output:
    void **p,               // pointer to object to free, does nothing if NULL
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Init
(
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Version
(
    // output:
    int version_number [3], // user-provided array of size 3
    char *version_date,     // user-provided array of size >= LAGRAPH_MSG_LEN
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Finalize
(
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_New
(
    // output:
    LAGraph_Graph *G,   // the graph to create, NULL if failure
    // input/output:
    GrB_Matrix    *A,   // the adjacency matrix of the graph, may be NULL.
                        // A is moved into G as G->A, and A itself is set
                        // to NULL to denote that is now a part of G.
                        // That is, { G->A = A ; A = NULL ; } is performed.
                        // When G is deleted, G->A is freed.  If A is NULL,
                        // the graph is invalid until G->A is set.
    // input:
    LAGraph_Kind kind,  // the kind of graph. This may be LAGRAPH_UNKNOWN,
                        // which must then be revised later before the
                        // graph can be used.
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Delete
(
    // input/output:
    LAGraph_Graph *G,   // the graph to delete; G set to NULL on output.
                        // All internal GrB_Matrix and GrB_Vector objects are
                        // freed, including G->A.  To keep G->A while deleting
                        // the graph G, use:
                        // { A = G->A ; G->A = NULL ; LAGraph_Delete (&G, msg);}
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_DeleteCached
(
    // input/output:
    LAGraph_Graph G,    // G stays valid, only cached properties are freed
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Cached_AT
(
    // input/output:
    LAGraph_Graph G,    // graph for which to compute G->AT
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Cached_IsSymmetricStructure
(
    // input/output:
    LAGraph_Graph G,    // graph to determine the symmetry of structure of A
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Cached_OutDegree
(
    // input/output:
    LAGraph_Graph G,    // graph to determine G->out_degree
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Cached_InDegree
(
    // input/output:
    LAGraph_Graph G,    // graph to determine G->in_degree
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Cached_NSelfEdges
(
    // input/output:
    LAGraph_Graph G,    // graph to compute G->nself_edges
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Cached_EMin
(
    // input/output:
    LAGraph_Graph G,    // graph to determine G->emin
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Cached_EMax
(
    // input/output:
    LAGraph_Graph G,    // graph to determine G->emax
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_DeleteSelfEdges
(
    // input/output:
    LAGraph_Graph G,    // diagonal entries removed, most cached properties
                        // cleared
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_CheckGraph
(
    // input/output:
    LAGraph_Graph G,    // graph to check
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_GetNumThreads
(
    // output:
    int *nthreads_outer,    // for outer region for nested parallelism
    int *nthreads_inner,    // for inner region of nested parallelism, or for
                            // the underlying GraphBLAS library
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_SetNumThreads
(
    // input:
    int nthreads_outer,
    int nthreads_inner,
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
double LAGraph_WallClockTime     // returns omp_get_wtime(), or other timer
(
    void
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_MMRead
(
    // output:
    GrB_Matrix *A,  // handle of matrix to create
    // input:
    FILE *f,        // file to read from, already open
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_MMWrite
(
    // input:
    GrB_Matrix A,       // matrix to write to the file
    FILE *f,            // file to write it to, must be already open
    FILE *fcomments,    // optional file with extra comments, may be NULL
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Matrix_Structure
(
    // output:
    GrB_Matrix *C,  // a boolean matrix with same structure of A, with C(i,j)
                    // set to true if A(i,j) appears in the sparsity structure
                    // of A.
    // input:
    GrB_Matrix A,
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Vector_Structure
(
    // output:
    GrB_Vector *w,  // a boolean vector with same structure of u, with w(i)
                    // set to true if u(i) appears in the sparsity structure
                    // of u.
    // input:
    GrB_Vector u,
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_NameOfType
(
    // output:
    char *name,     // name of the type: user provided array of size at
                    // least LAGRAPH_MAX_NAME_LEN.
    // input:
    GrB_Type type,  // GraphBLAS type
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_TypeFromName
(
    // output:
    GrB_Type *type, // GraphBLAS type
    // input:
    char *name,     // name of the type: a null-terminated string
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_SizeOfType
(
    // output:
    size_t *size,   // size of the type
    // input:
    GrB_Type type,  // GraphBLAS type
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Matrix_TypeName
(
    // output:
    char *name,     // name of the type of the matrix A (user-provided array
                    // of size at least LAGRAPH_MAX_NAME_LEN).
    // input:
    GrB_Matrix A,   // matrix to query
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Vector_TypeName
(
    // output:
    char *name,     // name of the type of the vector v (user-provided array
                    // of size at least LAGRAPH_MAX_NAME_LEN).
    // input:
    GrB_Vector v,   // vector to query
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Scalar_TypeName
(
    // output:
    char *name,     // name of the type of the scalar s (user-provided array
                    // of size at least LAGRAPH_MAX_NAME_LEN).
    // input:
    GrB_Scalar s,   // scalar to query
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_DisplayGraph
// FIXME: rename this
// int LAGraph_Graph_Print
(
    // input:
    const LAGraph_Graph G,  // graph to display
    LAGraph_PrintLevel pr,  // print level (0 to 5)
    FILE *f,                // file to write to, must already be open
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Matrix_Print
(
    // input:
    const GrB_Matrix A,     // matrix to pretty-print to the file
    LAGraph_PrintLevel pr,  // print level (0 to 5)
    FILE *f,            // file to write it to, must be already open; use
                        // stdout or stderr to print to those locations.
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Vector_Print
(
    // input:
    const GrB_Vector v,     // vector to pretty-print to the file
    LAGraph_PrintLevel pr,  // print level (0 to 5)
    FILE *f,            // file to write it to, must be already open; use
                        // stdout or stderr to print to those locations.
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Matrix_IsEqual
(
    // output:
    bool *result,       // true if A == B, false if A != B or error
    // input:
    const GrB_Matrix A,
    const GrB_Matrix B,
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Matrix_IsEqual_op
(
    // output:
    bool *result,           // true if A == B, false if A != B or error
    // input:
    const GrB_Matrix A,
    const GrB_Matrix B,
    const GrB_BinaryOp op,        // comparator to use
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Vector_IsEqual
(
    // output:
    bool *result,           // true if A == B, false if A != B or error
    // input:
    const GrB_Vector A,
    const GrB_Vector B,
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Vector_IsEqual_op
(
    // output:
    bool *result,           // true if A == B, false if A != B or error
    // input:
    const GrB_Vector A,
    const GrB_Vector B,
    const GrB_BinaryOp op,        // comparator to use
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Sort1
(
    // input/output:
    int64_t *A_0,       // size n array
    // input:
    const int64_t n,
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Sort2
(
    // input/output:
    int64_t *A_0,       // size n array
    int64_t *A_1,       // size n array
    // input:
    const int64_t n,
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_Sort3
(
    // input/output:
    int64_t *A_0,       // size n array
    int64_t *A_1,       // size n array
    int64_t *A_2,       // size n array
    // input:
    const int64_t n,
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGraph_TriangleCount
(
    // output:
    uint64_t *ntriangles,   // # of triangles
    // input/output:
    LAGraph_Graph  G,
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGr_Init
(
    // input:
    GrB_Mode mode,      // mode for GrB_Init or GxB_Init
    void * (* user_malloc_function  ) (size_t),
    void * (* user_calloc_function  ) (size_t, size_t),
    void * (* user_realloc_function ) (void *, size_t),
    void   (* user_free_function    ) (void *),
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGr_SortByDegree
(
    // output:
    int64_t **P_handle,     // P is returned as a permutation vector of size n
    // input:
    const LAGraph_Graph G,  // graph of n nodes
    bool byout,             // if true, sort G->out_degree, else G->in_degree
    bool ascending,         // sort in ascending or descending order
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGr_SampleDegree
(
    // output:
    double *sample_mean,    // sampled mean degree
    double *sample_median,  // sampled median degree
    // input:
    const LAGraph_Graph G,  // graph of n nodes
    bool byout,             // if true, sample G->out_degree, else G->in_degree
    int64_t nsamples,       // number of samples
    uint64_t seed,          // random number seed
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGr_BreadthFirstSearch
(
    // output:
    GrB_Vector *level,
    GrB_Vector *parent,
    // input:
    const LAGraph_Graph G,
    GrB_Index src,
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGr_ConnectedComponents
(
    // output:
    GrB_Vector *component,  // component(i)=s if node i is in the component
                            // whose representative node is s
    // input:
    const LAGraph_Graph G,  // input graph
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGr_SingleSourceShortestPath
(
    // output:
    GrB_Vector *path_length,    // path_length (i) is the length of the shortest
                                // path from the source vertex to vertex i
    // input:
    const LAGraph_Graph G,
    GrB_Index source,           // source vertex
    GrB_Scalar Delta,           // delta value for delta stepping
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGr_Betweenness
(
    // output:
    GrB_Vector *centrality,     // centrality(i): betweeness centrality of i
    // input:
    const LAGraph_Graph G,      // input graph
    const GrB_Index *sources,   // source vertices to compute shortest paths
    int32_t ns,                 // number of source vertices
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGr_PageRank
(
    // output:
    GrB_Vector *centrality, // centrality(i): pagerank of node i
    int *iters,             // number of iterations taken
    // input:
    const LAGraph_Graph G,  // input graph
    float damping,          // damping factor (typically 0.85)
    float tol,              // stopping tolerance (typically 1e-4) ;
    int itermax,            // maximum number of iterations (typically 100)
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGr_PageRankGAP
(
    // output:
    GrB_Vector *centrality, // centrality(i): GAP-style pagerank of node i
    int *iters,             // number of iterations taken
    // input:
    const LAGraph_Graph G,  // input graph
    float damping,          // damping factor (typically 0.85)
    float tol,              // stopping tolerance (typically 1e-4) ;
    int itermax,            // maximum number of iterations (typically 100)
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
int LAGr_TriangleCount
(
    // output:
    uint64_t *ntriangles,
    // input:
    const LAGraph_Graph G,
    LAGraph_TriangleCount_Method method,
    LAGraph_TriangleCount_Presort *presort,
    char *msg
) ;
\end{verbatim}




\begin{verbatim}
typedef enum
{
    LAGraph_ADJACENCY_UNDIRECTED = 0, // A is square and symmetric; both upper
                                      // and lower triangular parts are
                                      // present.  A(i,j) is the edge (i,j)

    LAGraph_ADJACENCY_DIRECTED = 1,   // A is square; A(i,j) is the edge (i,j)

    // possible future kinds of graphs:
    // LAGraph_ADJACENCY_UNDIRECTED_UNWEIGHTED
    // LAGraph_ADJACENCY_DIRECTED_UNWEIGHTED
    // LAGraph_ADJACENCY_UNDIRECTED_TRIL
    // LAGraph_ADJACENCY_UNDIRECTED_TRIU
    // LAGraph_BIPARTITE
    // LAGraph_BIPARTITE_DIRECTED
    // LAGraph_BIPARTITE_UNDIRECTED
    // LAGraph_INCIDENCE_*
    // LAGraph_MULTIGRAPH_*
    // LAGraph_HYPERGRAPH
    // LAGraph_HYPERGRAPH_DIRECTED
    // ...

    LAGraph_KIND_UNKNOWN = LAGRAPH_UNKNOWN      // the graph kind is unknown
}
LAGraph_Kind ;
\end{verbatim}




\begin{verbatim}
typedef enum
{
    LAGraph_FALSE = 0,
    LAGraph_TRUE = 1,
    LAGraph_BOOLEAN_UNKNOWN = LAGRAPH_UNKNOWN
}
LAGraph_Boolean ;
\end{verbatim}




\begin{verbatim}
typedef enum
{
    LAGraph_VALUE = 0,  // cached property is a known value (ignoring roundoff)
    LAGraph_BOUND = 1,  // cached property is a bound (upper or lower,
                        // depending on the particular cached property)
    LAGraph_STATE_UNKNOWN = LAGRAPH_UNKNOWN,
}
LAGraph_State ;
\end{verbatim}




\begin{verbatim}
typedef enum
{
    LAGraph_SILENT = 0,     // nothing is printed
    LAGraph_SUMMARY = 1,    // print a terse summary
    LAGraph_SHORT = 2,      // short description, about 30 entries of a matrix
    LAGraph_COMPLETE = 3,   // print the entire contents of the object
    LAGraph_SHORT_VERBOSE = 4,    // LAGraph_SHORT but with "%.15g" for doubles
    LAGraph_COMPLETE_VERBOSE = 5  // LAGraph_COMPLETE, but "%.15g" for doubles
    // FUTURE:
    // LAGraph_SHORT_ARRAY ...
    // LAGraph_COMPLETE_ARRAY ...
    //
    //      .  3.3 . 9 .
    //     99  32  . . .
    //
    // LAGraph_SHORT_STRUCTURE ...
    // LAGraph_COMPLETE_STRUCTURE ...
    //
    //      . x . x x x .
    //      x x . x x x .
    //      . x . x . x .
    //      . . . . x x .
    // FUTURE: # of digits per entry? automatic digits per column?
}
LAGraph_PrintLevel ;
\end{verbatim}




\begin{verbatim}
typedef enum
{
    LAGraph_TriangleCount_Default = 0,      // use default method
    LAGraph_TriangleCount_Burkhardt = 1,    // sum (sum ((A^2) .* A)) / 6
    LAGraph_TriangleCount_Cohen = 2,        // sum (sum ((L * U) .* A)) / 2
    LAGraph_TriangleCount_Sandia = 3,       // sum (sum ((L * L) .* L))
    LAGraph_TriangleCount_Sandia2 = 4,      // sum (sum ((U * U) .* U))
    LAGraph_TriangleCount_SandiaDot = 5,    // sum (sum ((L * U') .* L))
    LAGraph_TriangleCount_SandiaDot2 = 6,   // sum (sum ((U * L') .* U))
}
LAGraph_TriangleCount_Method ;
\end{verbatim}




\begin{verbatim}
typedef enum
{
    LAGraph_TriangleCount_NoSort = 0,       // no sort
    LAGraph_TriangleCount_Ascending = 1,    // sort by degree, ascending order
    LAGraph_TriangleCount_Descending = -1,  // sort by degree, descending order
    LAGraph_TriangleCount_AutoSort = 2,     // auto selection: no sort if rule
    // is not triggered.  Otherwise: sort in ascending order for methods 3 and
    // 5, descending ordering for methods 4 and 6.  On output, presort is
    // modified to reflect the sorting method used (0, -1, or 1).  If presort
    // is NULL on input, no sort is performed.
}
LAGraph_TriangleCount_Presort ;
\end{verbatim}




